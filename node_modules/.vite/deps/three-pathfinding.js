import {
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Line,
  LineBasicMaterial,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  Plane,
  SphereGeometry,
  Triangle,
  Vector3
} from "./chunk-UZOV2HZI.js";
import "./chunk-BUSYA2B4.js";

// node_modules/three-pathfinding/dist/three-pathfinding.module.js
var d = class {
  static roundNumber(t, e) {
    const s = Math.pow(10, e);
    return Math.round(t * s) / s;
  }
  static sample(t) {
    return t[Math.floor(Math.random() * t.length)];
  }
  static distanceToSquared(t, e) {
    var s = t.x - e.x, r = t.y - e.y, n = t.z - e.z;
    return s * s + r * r + n * n;
  }
  static isPointInPoly(t, e) {
    for (var s = false, r = -1, n = t.length, o = n - 1; ++r < n; o = r) (t[r].z <= e.z && e.z < t[o].z || t[o].z <= e.z && e.z < t[r].z) && e.x < (t[o].x - t[r].x) * (e.z - t[r].z) / (t[o].z - t[r].z) + t[r].x && (s = !s);
    return s;
  }
  static isVectorInPolygon(t, e, s) {
    var r = 1e5, n = -1e5, o = [];
    return e.vertexIds.forEach((t2) => {
      r = Math.min(s[t2].y, r), n = Math.max(s[t2].y, n), o.push(s[t2]);
    }), !!(t.y < n + 0.5 && t.y > r - 0.5 && this.isPointInPoly(o, t));
  }
  static triarea2(t, e, s) {
    return (s.x - t.x) * (e.z - t.z) - (e.x - t.x) * (s.z - t.z);
  }
  static vequal(t, e) {
    return this.distanceToSquared(t, e) < 1e-5;
  }
  static mergeVertices(s, r = 1e-4) {
    r = Math.max(r, Number.EPSILON);
    for (var n = {}, o = s.getIndex(), i = s.getAttribute("position"), h = o ? o.count : i.count, c = 0, a = [], u = [], l = Math.log10(1 / r), d2 = Math.pow(10, l), p2 = 0; p2 < h; p2++) {
      var g2 = o ? o.getX(p2) : p2, f2 = "";
      f2 += ~~(i.getX(g2) * d2) + ",", f2 += ~~(i.getY(g2) * d2) + ",", (f2 += ~~(i.getZ(g2) * d2) + ",") in n ? a.push(n[f2]) : (u.push(i.getX(g2)), u.push(i.getY(g2)), u.push(i.getZ(g2)), n[f2] = c, a.push(c), c++);
    }
    const v2 = new BufferAttribute(new Float32Array(u), i.itemSize, i.normalized), b = new BufferGeometry();
    return b.setAttribute("position", v2), b.setIndex(a), b;
  }
};
var p = class {
  constructor(t) {
    this.content = [], this.scoreFunction = t;
  }
  push(t) {
    this.content.push(t), this.sinkDown(this.content.length - 1);
  }
  pop() {
    const t = this.content[0], e = this.content.pop();
    return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t;
  }
  remove(t) {
    const e = this.content.indexOf(t), s = this.content.pop();
    e !== this.content.length - 1 && (this.content[e] = s, this.scoreFunction(s) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(t) {
    this.sinkDown(this.content.indexOf(t));
  }
  sinkDown(t) {
    const e = this.content[t];
    for (; t > 0; ) {
      const s = (t + 1 >> 1) - 1, r = this.content[s];
      if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;
      this.content[s] = e, this.content[t] = r, t = s;
    }
  }
  bubbleUp(t) {
    const e = this.content.length, s = this.content[t], r = this.scoreFunction(s);
    for (; ; ) {
      const n = t + 1 << 1, o = n - 1;
      let i, h = null;
      if (o < e && (i = this.scoreFunction(this.content[o]), i < r && (h = o)), n < e && this.scoreFunction(this.content[n]) < (null === h ? r : i) && (h = n), null === h) break;
      this.content[t] = this.content[h], this.content[h] = s, t = h;
    }
  }
};
var g = class {
  constructor() {
    this.portals = [];
  }
  push(t, e) {
    void 0 === e && (e = t), this.portals.push({ left: t, right: e });
  }
  stringPull() {
    const t = this.portals, e = [];
    let s, r, n, o = 0, i = 0, h = 0;
    s = t[0].left, r = t[0].left, n = t[0].right, e.push(s);
    for (let c = 1; c < t.length; c++) {
      const a = t[c].left, u = t[c].right;
      if (d.triarea2(s, n, u) <= 0) {
        if (!(d.vequal(s, n) || d.triarea2(s, r, u) > 0)) {
          e.push(r), s = r, o = i, r = s, n = s, i = o, h = o, c = o;
          continue;
        }
        n = u, h = c;
      }
      if (d.triarea2(s, r, a) >= 0) {
        if (!(d.vequal(s, r) || d.triarea2(s, n, a) < 0)) {
          e.push(n), s = n, o = h, r = s, n = s, i = o, h = o, c = o;
          continue;
        }
        r = a, i = c;
      }
    }
    return 0 !== e.length && d.vequal(e[e.length - 1], t[t.length - 1].left) || e.push(t[t.length - 1].left), this.path = e, e;
  }
};
var f = class {
  constructor() {
    this.zones = {};
  }
  static createZone(t, e = 1e-4) {
    return (class {
      static buildZone(t2, e2) {
        const r = this._buildNavigationMesh(t2, e2), n = {};
        r.vertices.forEach((t3) => {
          t3.x = d.roundNumber(t3.x, 2), t3.y = d.roundNumber(t3.y, 2), t3.z = d.roundNumber(t3.z, 2);
        }), n.vertices = r.vertices;
        const o = this._buildPolygonGroups(r);
        return n.groups = new Array(o.length), o.forEach((t3, e3) => {
          const r2 = /* @__PURE__ */ new Map();
          t3.forEach((t4, e4) => {
            r2.set(t4, e4);
          });
          const o2 = new Array(t3.length);
          t3.forEach((t4, e4) => {
            const i = [];
            t4.neighbours.forEach((t5) => i.push(r2.get(t5)));
            const h = [];
            t4.neighbours.forEach((e5) => h.push(this._getSharedVerticesInOrder(t4, e5)));
            const c = new Vector3(0, 0, 0);
            c.add(n.vertices[t4.vertexIds[0]]), c.add(n.vertices[t4.vertexIds[1]]), c.add(n.vertices[t4.vertexIds[2]]), c.divideScalar(3), c.x = d.roundNumber(c.x, 2), c.y = d.roundNumber(c.y, 2), c.z = d.roundNumber(c.z, 2), o2[e4] = { id: e4, neighbours: i, vertexIds: t4.vertexIds, centroid: c, portals: h };
          }), n.groups[e3] = o2;
        }), n;
      }
      static _buildNavigationMesh(t2, e2) {
        return t2 = d.mergeVertices(t2, e2), this._buildPolygonsFromGeometry(t2);
      }
      static _spreadGroupId(t2) {
        let e2 = /* @__PURE__ */ new Set([t2]);
        for (; e2.size > 0; ) {
          const s = e2;
          e2 = /* @__PURE__ */ new Set(), s.forEach((s2) => {
            s2.group = t2.group, s2.neighbours.forEach((t3) => {
              void 0 === t3.group && e2.add(t3);
            });
          });
        }
      }
      static _buildPolygonGroups(t2) {
        const e2 = [];
        return t2.polygons.forEach((t3) => {
          void 0 !== t3.group ? e2[t3.group].push(t3) : (t3.group = e2.length, this._spreadGroupId(t3), e2.push([t3]));
        }), e2;
      }
      static _buildPolygonNeighbours(t2, e2) {
        const s = /* @__PURE__ */ new Set(), r = e2[t2.vertexIds[1]], n = e2[t2.vertexIds[2]];
        return e2[t2.vertexIds[0]].forEach((e3) => {
          e3 !== t2 && (r.includes(e3) || n.includes(e3)) && s.add(e3);
        }), r.forEach((e3) => {
          e3 !== t2 && n.includes(e3) && s.add(e3);
        }), s;
      }
      static _buildPolygonsFromGeometry(t2) {
        const e2 = [], r = [], n = t2.attributes.position, o = t2.index, i = [];
        for (let t3 = 0; t3 < n.count; t3++) r.push(new Vector3().fromBufferAttribute(n, t3)), i[t3] = [];
        for (let s = 0; s < t2.index.count; s += 3) {
          const t3 = o.getX(s), r2 = o.getX(s + 1), n2 = o.getX(s + 2), h = { vertexIds: [t3, r2, n2], neighbours: null };
          e2.push(h), i[t3].push(h), i[r2].push(h), i[n2].push(h);
        }
        return e2.forEach((t3) => {
          t3.neighbours = this._buildPolygonNeighbours(t3, i);
        }), { polygons: e2, vertices: r };
      }
      static _getSharedVerticesInOrder(t2, e2) {
        const s = t2.vertexIds, r = s[0], n = s[1], o = s[2], i = e2.vertexIds, h = i.includes(r), c = i.includes(n), a = i.includes(o);
        return h && c && a ? Array.from(s) : h && c ? [r, n] : c && a ? [n, o] : h && a ? [o, r] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), []);
      }
    }).buildZone(t, e);
  }
  setZoneData(t, e) {
    this.zones[t] = e;
  }
  getRandomNode(t, e, r, n) {
    if (!this.zones[t]) return new Vector3();
    r = r || null, n = n || 0;
    const o = [];
    return this.zones[t].groups[e].forEach((t2) => {
      r && n ? d.distanceToSquared(r, t2.centroid) < n * n && o.push(t2.centroid) : o.push(t2.centroid);
    }), d.sample(o) || new Vector3();
  }
  getClosestNode(t, e, s, r = false) {
    const n = this.zones[e].vertices;
    let o = null, i = Infinity;
    return this.zones[e].groups[s].forEach((e2) => {
      const s2 = d.distanceToSquared(e2.centroid, t);
      s2 < i && (!r || d.isVectorInPolygon(t, e2, n)) && (o = e2, i = s2);
    }), o;
  }
  findPath(t, e, r, n) {
    const o = this.zones[r].groups[n], i = this.zones[r].vertices, h = this.getClosestNode(t, r, n, true), c = this.getClosestNode(e, r, n, true);
    if (!h || !c) return null;
    const a = (class {
      static init(t2) {
        for (let e2 = 0; e2 < t2.length; e2++) {
          const s = t2[e2];
          s.f = 0, s.g = 0, s.h = 0, s.cost = 1, s.visited = false, s.closed = false, s.parent = null;
        }
      }
      static cleanUp(t2) {
        for (let e2 = 0; e2 < t2.length; e2++) {
          const s = t2[e2];
          delete s.f, delete s.g, delete s.h, delete s.cost, delete s.visited, delete s.closed, delete s.parent;
        }
      }
      static heap() {
        return new p(function(t2) {
          return t2.f;
        });
      }
      static search(t2, e2, s) {
        this.init(t2);
        const r2 = this.heap();
        for (r2.push(e2); r2.size() > 0; ) {
          const e3 = r2.pop();
          if (e3 === s) {
            let t3 = e3;
            const s2 = [];
            for (; t3.parent; ) s2.push(t3), t3 = t3.parent;
            return this.cleanUp(s2), s2.reverse();
          }
          e3.closed = true;
          const n2 = this.neighbours(t2, e3);
          for (let t3 = 0, o2 = n2.length; t3 < o2; t3++) {
            const o3 = n2[t3];
            if (o3.closed) continue;
            const i2 = e3.g + o3.cost, h2 = o3.visited;
            if (!h2 || i2 < o3.g) {
              if (o3.visited = true, o3.parent = e3, !o3.centroid || !s.centroid) throw new Error("Unexpected state");
              o3.h = o3.h || this.heuristic(o3.centroid, s.centroid), o3.g = i2, o3.f = o3.g + o3.h, h2 ? r2.rescoreElement(o3) : r2.push(o3);
            }
          }
        }
        return [];
      }
      static heuristic(t2, e2) {
        return d.distanceToSquared(t2, e2);
      }
      static neighbours(t2, e2) {
        const s = [];
        for (let r2 = 0; r2 < e2.neighbours.length; r2++) s.push(t2[e2.neighbours[r2]]);
        return s;
      }
    }).search(o, h, c), u = function(t2, e2) {
      for (var s = 0; s < t2.neighbours.length; s++) if (t2.neighbours[s] === e2.id) return t2.portals[s];
    }, l = new g();
    l.push(t);
    for (let t2 = 0; t2 < a.length; t2++) {
      const e2 = a[t2], s = a[t2 + 1];
      if (s) {
        const t3 = u(e2, s);
        l.push(i[t3[0]], i[t3[1]]);
      }
    }
    l.push(e), l.stringPull();
    const f2 = l.path.map((t2) => new Vector3(t2.x, t2.y, t2.z));
    return f2.shift(), f2;
  }
};
f.prototype.getGroup = function() {
  const t = new Plane();
  return function(e, s, r = false) {
    if (!this.zones[e]) return null;
    let n = null, o = Math.pow(50, 2);
    const i = this.zones[e];
    for (let e2 = 0; e2 < i.groups.length; e2++) {
      const h = i.groups[e2];
      for (const c of h) {
        if (r && (t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]), Math.abs(t.distanceToPoint(s)) < 0.01) && d.isPointInPoly([i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]], s)) return e2;
        const h2 = d.distanceToSquared(c.centroid, s);
        h2 < o && (n = e2, o = h2);
      }
    }
    return n;
  };
}(), f.prototype.clampStep = function() {
  const t = new Vector3(), e = new Plane(), o = new Triangle(), i = new Vector3();
  let h, c, a = new Vector3();
  return function(s, r, n, u, l, d2) {
    const p2 = this.zones[u].vertices, g2 = this.zones[u].groups[l], f2 = [n], v2 = {};
    v2[n.id] = 0, h = void 0, a.set(0, 0, 0), c = Infinity, e.setFromCoplanarPoints(p2[n.vertexIds[0]], p2[n.vertexIds[1]], p2[n.vertexIds[2]]), e.projectPoint(r, t), i.copy(t);
    for (let e2 = f2.pop(); e2; e2 = f2.pop()) {
      o.set(p2[e2.vertexIds[0]], p2[e2.vertexIds[1]], p2[e2.vertexIds[2]]), o.closestPointToPoint(i, t), t.distanceToSquared(i) < c && (h = e2, a.copy(t), c = t.distanceToSquared(i));
      const s2 = v2[e2.id];
      if (!(s2 > 2)) for (let t2 = 0; t2 < e2.neighbours.length; t2++) {
        const r2 = g2[e2.neighbours[t2]];
        r2.id in v2 || (f2.push(r2), v2[r2.id] = s2 + 1);
      }
    }
    return d2.copy(a), h;
  };
}();
var v = class extends Object3D {
  constructor() {
    super(), this._playerMarker = new Mesh(new SphereGeometry(0.25, 32, 32), new MeshBasicMaterial({ color: 15631215 })), this._targetMarker = new Mesh(new BoxGeometry(0.3, 0.3, 0.3), new MeshBasicMaterial({ color: 14469912 })), this._nodeMarker = new Mesh(new BoxGeometry(0.1, 0.8, 0.1), new MeshBasicMaterial({ color: 4417387 })), this._stepMarker = new Mesh(new BoxGeometry(0.1, 1, 0.1), new MeshBasicMaterial({ color: 14472114 })), this._pathMarker = new Object3D(), this._pathLineMaterial = new LineBasicMaterial({ color: 41903, linewidth: 2 }), this._pathPointMaterial = new MeshBasicMaterial({ color: 41903 }), this._pathPointGeometry = new SphereGeometry(0.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach((t) => {
      t.visible = false, this.add(t);
    });
  }
  setPath(s) {
    for (; this._pathMarker.children.length; ) this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
    s = [this._playerMarker.position].concat(s);
    const r = new BufferGeometry();
    r.setAttribute("position", new BufferAttribute(new Float32Array(3 * s.length), 3));
    for (let t = 0; t < s.length; t++) r.attributes.position.setXYZ(t, s[t].x, s[t].y + 0.2, s[t].z);
    this._pathMarker.add(new Line(r, this._pathLineMaterial));
    for (let t = 0; t < s.length - 1; t++) {
      const e = new Mesh(this._pathPointGeometry, this._pathPointMaterial);
      e.position.copy(s[t]), e.position.y += 0.2, this._pathMarker.add(e);
    }
    return this._pathMarker.visible = true, this;
  }
  setPlayerPosition(t) {
    return this._playerMarker.position.copy(t), this._playerMarker.visible = true, this;
  }
  setTargetPosition(t) {
    return this._targetMarker.position.copy(t), this._targetMarker.visible = true, this;
  }
  setNodePosition(t) {
    return this._nodeMarker.position.copy(t), this._nodeMarker.visible = true, this;
  }
  setStepPosition(t) {
    return this._stepMarker.position.copy(t), this._stepMarker.visible = true, this;
  }
  reset() {
    for (; this._pathMarker.children.length; ) this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
    return this._markers.forEach((t) => {
      t.visible = false;
    }), this;
  }
};
export {
  f as Pathfinding,
  v as PathfindingHelper
};
//# sourceMappingURL=three-pathfinding.js.map
