{
  "version": 3,
  "sources": ["../../three-pathfinding/src/Utils.js", "../../three-pathfinding/src/BinaryHeap.js", "../../three-pathfinding/src/Channel.js", "../../three-pathfinding/src/Pathfinding.js", "../../three-pathfinding/src/Builder.js", "../../three-pathfinding/src/AStar.js", "../../three-pathfinding/src/PathfindingHelper.js"],
  "sourcesContent": ["import { BufferAttribute, BufferGeometry } from 'three';\n\nclass Utils {\n\n  static roundNumber (value, decimals) {\n    const factor = Math.pow(10, decimals);\n    return Math.round(value * factor) / factor;\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n\n  /**\n   * Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\n   * attributes other than position.\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {THREE.BufferGeometry>}\n   */\n  static mergeVertices (geometry, tolerance = 1e-4) {\n\n    tolerance = Math.max( tolerance, Number.EPSILON );\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute( 'position' );\n    var vertexCount = indices ? indices.count : positions.count;\n\n    // Next value for triangle indices.\n    var nextIndex = 0;\n\n    var newIndices = [];\n    var newPositions = [];\n\n    // Convert the error tolerance to an amount of decimal places to truncate to.\n    var decimalShift = Math.log10( 1 / tolerance );\n    var shiftMultiplier = Math.pow( 10, decimalShift );\n\n    for ( var i = 0; i < vertexCount; i ++ ) {\n\n      var index = indices ? indices.getX( i ) : i;\n\n      // Generate a hash for the vertex attributes at the current index 'i'.\n      var hash = '';\n\n      // Double tilde truncates the decimal value.\n      hash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\n\n      // Add another reference to the vertex if it's already\n      // used by another index.\n      if ( hash in hashToIndex ) {\n\n        newIndices.push( hashToIndex[ hash ] );\n\n      } else {\n\n        newPositions.push( positions.getX( index ) );\n        newPositions.push( positions.getY( index ) );\n        newPositions.push( positions.getZ( index ) );\n\n        hashToIndex[ hash ] = nextIndex;\n        newIndices.push( nextIndex );\n        nextIndex ++;\n\n      }\n\n    }\n\n    // Construct merged BufferGeometry.\n\n    const positionAttribute = new BufferAttribute(\n      new Float32Array( newPositions ),\n      positions.itemSize,\n      positions.normalized\n    );\n\n    const result = new BufferGeometry();\n    result.setAttribute( 'position', positionAttribute );\n    result.setIndex( newIndices );\n\n    return result;\n\n  }\n}\n\nexport { Utils };\n", "// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n", "import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n", "import {\n\tVector3,\n\tPlane,\n\tTriangle,\n} from 'three';\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {BufferGeometry} geometry\n\t * @param  {number} tolerance Vertex welding tolerance.\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry, tolerance = 1e-4) {\n\t\treturn Builder.buildZone(geometry, tolerance);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {Vector3} startPosition Start position.\n\t * @param  {Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID, true);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Returns closest node group ID for given position.\n * @param  {string} zoneID\n * @param  {Vector3} position\n * @return {number}\n */\nPathfinding.prototype.getGroup = (function() {\n\tconst plane = new Plane();\n\treturn function (zoneID, position, checkPolygon = false) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\t\tconst zone = this.zones[zoneID];\n\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\n\t\t\tconst group = zone.groups[i];\n\t\t\tfor (const node of group) {\n\t\t\t\tif (checkPolygon) {\n\t\t\t\t\tplane.setFromCoplanarPoints(\n\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t);\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\n\t\t\t\t\t\tconst poly = [\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = i;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closestNodeGroup;\n\t};\n}());\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {Vector3} start\n * @param  {Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new Vector3();\n\tconst plane = new Plane();\n\tconst triangle = new Triangle();\n\n\tconst endPoint = new Vector3();\n\n\tlet closestNode;\n\tlet closestPoint = new Vector3();\n\tlet closestDistance;\n\n\treturn function (startRef, endRef, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(endRef, point);\n\t\tendPoint.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(endPoint, point);\n\n\t\t\tif (point.distanceToSquared(endPoint) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(endPoint);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode.id];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<Vector3>} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number>} vertexIds\n * @property {Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n", "import { Vector3 } from 'three';\n\nimport { Utils } from './Utils';\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {BufferGeometry} geometry\n   * @param  {number} tolerance\n   * @return {Zone}\n   */\n  static buildZone (geometry, tolerance) {\n\n    const navMesh = this._buildNavigationMesh(geometry, tolerance);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    // TODO: This block represents a large portion of navigation mesh construction time\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    zone.groups = new Array(groups.length);\n    groups.forEach((group, groupIndex) => {\n\n      const indexByPolygon = new Map(); // { polygon: index in group }\n      group.forEach((poly, polyIndex) => { indexByPolygon.set(poly, polyIndex); });\n\n      const newGroup = new Array(group.length);\n      group.forEach((poly, polyIndex) => {\n\n        const neighbourIndices = [];\n        poly.neighbours.forEach((n) => neighbourIndices.push(indexByPolygon.get(n)));\n\n        // Build a portal list to each neighbour\n        const portals = [];\n        poly.neighbours.forEach((n) => portals.push(this._getSharedVerticesInOrder(poly, n)));\n\n        const centroid = new Vector3( 0, 0, 0 );\n        centroid.add( zone.vertices[ poly.vertexIds[0] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[1] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[2] ] );\n        centroid.divideScalar( 3 );\n        centroid.x = Utils.roundNumber(centroid.x, 2);\n        centroid.y = Utils.roundNumber(centroid.y, 2);\n        centroid.z = Utils.roundNumber(centroid.z, 2);\n\n        newGroup[polyIndex] = {\n          id: polyIndex,\n          neighbours: neighbourIndices,\n          vertexIds: poly.vertexIds,\n          centroid: centroid,\n          portals: portals\n        };\n      });\n\n      zone.groups[groupIndex] = newGroup;\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {BufferGeometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry, tolerance) {\n    geometry = Utils.mergeVertices(geometry, tolerance);\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  /**\n   * Spreads the group ID of the given polygon to all connected polygons\n   * @param {Object} seed\n   */\n  static _spreadGroupId (seed) {\n    let nextBatch = new Set([seed]);\n\n    while(nextBatch.size > 0) {\n      const batch = nextBatch;\n      nextBatch = new Set();\n\n      batch.forEach((polygon) => {\n        polygon.group = seed.group;\n        polygon.neighbours.forEach((neighbour) => {\n          if(neighbour.group === undefined) {\n            nextBatch.add(neighbour);\n          }\n        });\n      });\n    }\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n\n    polygons.forEach((polygon) => {\n      if (polygon.group !== undefined) {\n        // this polygon is already part of a group\n        polygonGroups[polygon.group].push(polygon);\n      } else {\n        // we need to make a new group and spread its ID to neighbors\n        polygon.group = polygonGroups.length;\n        this._spreadGroupId(polygon);\n        polygonGroups.push([polygon]);\n      }\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, vertexPolygonMap) {\n    const neighbours = new Set();\n\n    const groupA = vertexPolygonMap[polygon.vertexIds[0]];\n    const groupB = vertexPolygonMap[polygon.vertexIds[1]];\n    const groupC = vertexPolygonMap[polygon.vertexIds[2]];\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bublé cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupB.includes(candidate) || groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n\n    return neighbours;\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = [];\n\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n\n    /** Array of polygon objects by vertex index. */\n    const vertexPolygonMap = [];\n\n    for (let i = 0; i < position.count; i++) {\n      vertices.push(new Vector3().fromBufferAttribute(position, i));\n      vertexPolygonMap[i] = [];\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    for (let i = 0; i < geometry.index.count; i += 3) {\n      const a = index.getX(i);\n      const b = index.getX(i + 1);\n      const c = index.getX(i + 2);\n      const poly = {vertexIds: [a, b, c], neighbours: null};\n      polygons.push(poly);\n      vertexPolygonMap[a].push(poly);\n      vertexPolygonMap[b].push(poly);\n      vertexPolygonMap[c].push(poly);\n    }\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      polygon.neighbours = this._buildPolygonNeighbours(polygon, vertexPolygonMap);\n    });\n\n    return {\n      polygons: polygons,\n      vertices: vertices\n    };\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const a0 = aList[0], a1 = aList[1], a2 = aList[2];\n\n    const bList = b.vertexIds;\n    const shared0 = bList.includes(a0);\n    const shared1 = bList.includes(a1);\n    const shared2 = bList.includes(a2);\n\n    // it seems that we shouldn't have an a and b with <2 shared vertices here unless there's a bug\n    // in the neighbor identification code, or perhaps a malformed input geometry; 3 shared vertices\n    // is a kind of embarrassing but possible geometry we should handle\n    if (shared0 && shared1 && shared2) {\n      return Array.from(aList);\n    } else if (shared0 && shared1) {\n      return [a0, a1];\n    } else if (shared1 && shared2) {\n      return [a1, a2];\n    } else if (shared0 && shared2) {\n      return [a2, a0]; // this ordering will affect the string pull algorithm later, not clear if significant\n    } else {\n      console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\");\n      return [];\n    }\n  }\n}\n\nexport { Builder };\n", "import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n", "import {\n  BoxGeometry,\n  SphereGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  Line,\n  LineBasicMaterial,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Vector3,\n} from 'three';\n\nconst colors = {\n  PLAYER: 0xEE836F,\n  TARGET: 0xDCCB18,\n  PATH: 0x00A3AF,\n  WAYPOINT: 0x00A3AF,\n  CLAMPED_STEP: 0xDCD3B2,\n  CLOSEST_NODE: 0x43676B,\n};\n\nconst OFFSET = 0.2;\n\n/**\n * Helper for debugging pathfinding behavior.\n */\nclass PathfindingHelper extends Object3D {\n  constructor () {\n    super();\n\n    this._playerMarker = new Mesh(\n      new SphereGeometry( 0.25, 32, 32 ),\n      new MeshBasicMaterial( { color: colors.PLAYER } )\n    );\n\n    this._targetMarker = new Mesh(\n      new BoxGeometry( 0.3, 0.3, 0.3 ),\n      new MeshBasicMaterial( { color: colors.TARGET } )\n    );\n\n\n    this._nodeMarker = new Mesh(\n      new BoxGeometry( 0.1, 0.8, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLOSEST_NODE } )\n    );\n\n\n    this._stepMarker = new Mesh(\n      new BoxGeometry( 0.1, 1, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLAMPED_STEP } )\n    );\n\n    this._pathMarker = new Object3D();\n\n    this._pathLineMaterial = new LineBasicMaterial( { color: colors.PATH, linewidth: 2 } ) ;\n    this._pathPointMaterial = new MeshBasicMaterial( { color: colors.WAYPOINT } );\n    this._pathPointGeometry = new SphereGeometry( 0.08 );\n\n    this._markers = [\n      this._playerMarker,\n      this._targetMarker,\n      this._nodeMarker,\n      this._stepMarker,\n      this._pathMarker,\n    ];\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n      this.add( marker );\n\n    } );\n\n  }\n\n  /**\n   * @param {Array<Vector3>} path\n   * @return {this}\n   */\n  setPath ( path ) {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    path = [ this._playerMarker.position ].concat( path );\n\n    // Draw debug lines\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(path.length * 3), 3));\n    for (let i = 0; i < path.length; i++) {\n      geometry.attributes.position.setXYZ(i, path[ i ].x, path[ i ].y + OFFSET, path[ i ].z);\n    }\n    this._pathMarker.add( new Line( geometry, this._pathLineMaterial ) );\n\n    for ( let i = 0; i < path.length - 1; i++ ) {\n\n      const node = new Mesh( this._pathPointGeometry, this._pathPointMaterial );\n      node.position.copy( path[ i ] );\n      node.position.y += OFFSET;\n      this._pathMarker.add( node );\n\n    }\n\n    this._pathMarker.visible = true;\n\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setPlayerPosition( position ) {\n\n    this._playerMarker.position.copy( position );\n    this._playerMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setTargetPosition( position ) {\n\n    this._targetMarker.position.copy( position );\n    this._targetMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setNodePosition( position ) {\n\n    this._nodeMarker.position.copy( position );\n    this._nodeMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setStepPosition( position ) {\n\n    this._stepMarker.position.copy( position );\n    this._stepMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * Hides all markers.\n   * @return {this}\n   */\n  reset () {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n    } );\n\n    return this;\n\n  }\n\n}\n\nexport { PathfindingHelper };\n"],
  "mappings": "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",
  "names": ["Utils", "static", "value", "decimals", "factor", "Math", "pow", "round", "list", "floor", "random", "length", "a", "b", "dx", "x", "dy", "y", "dz", "z", "poly", "pt", "c", "i", "l", "j", "vector", "polygon", "vertices", "lowestPoint", "highestPoint", "polygonVertices", "vertexIds", "forEach", "vId", "min", "max", "push", "this", "isPointInPoly", "distanceToSquared", "geometry", "tolerance", "Number", "EPSILON", "hashToIndex", "indices", "getIndex", "positions", "getAttribute", "vertexCount", "count", "nextIndex", "newIndices", "newPositions", "decimalShift", "log10", "shiftMultiplier", "index", "getX", "hash", "getY", "getZ", "positionAttribute", "BufferAttribute", "Float32Array", "itemSize", "normalized", "result", "BufferGeometry", "setAttribute", "setIndex", "BinaryHeap", "constructor", "scoreFunction", "content", "element", "sinkDown", "pop", "end", "bubbleUp", "remove", "node", "indexOf", "size", "rescoreElement", "n", "parentN", "parent", "elemScore", "child2N", "child1N", "child1Score", "swap", "Channel", "portals", "p1", "p2", "left", "right", "stringPull", "pts", "portalApex", "portalLeft", "portalRight", "apexIndex", "leftIndex", "rightIndex", "triarea2", "vequal", "path", "Pathfinding", "zones", "navMesh", "_buildNavigationMesh", "zone", "v", "roundNumber", "groups", "_buildPolygonGroups", "Array", "group", "groupIndex", "indexByPolygon", "Map", "polyIndex", "set", "newGroup", "neighbourIndices", "neighbours", "get", "_getSharedVerticesInOrder", "centroid", "Vector3", "add", "divideScalar", "id", "mergeVertices", "_buildPolygonsFromGeometry", "seed", "nextBatch", "Set", "batch", "neighbour", "navigationMesh", "polygonGroups", "polygons", "_spreadGroupId", "vertexPolygonMap", "groupB", "groupC", "candidate", "includes", "position", "attributes", "fromBufferAttribute", "_buildPolygonNeighbours", "aList", "a0", "a1", "a2", "bList", "shared0", "shared1", "shared2", "from", "console", "warn", "buildZone", "setZoneData", "zoneID", "getRandomNode", "groupID", "nearPosition", "nearRange", "candidates", "p", "sample", "getClosestNode", "checkPolygon", "closestNode", "closestDistance", "Infinity", "distance", "isVectorInPolygon", "findPath", "startPosition", "targetPosition", "nodes", "farthestNode", "paths", "graph", "f", "g", "h", "cost", "visited", "closed", "start", "init", "openHeap", "heap", "currentNode", "curr", "ret", "cleanUp", "reverse", "il", "gScore", "beenVisited", "Error", "heuristic", "pos1", "pos2", "e", "search", "getPortalFromTo", "channel", "nextPolygon", "map", "shift", "prototype", "getGroup", "plane", "Plane", "closestNodeGroup", "setFromCoplanarPoints", "abs", "distanceToPoint", "measuredDistance", "clampStep", "point", "triangle", "Triangle", "endPoint", "closestPoint", "startRef", "endRef", "endTarget", "nodeQueue", "nodeDepth", "projectPoint", "copy", "closestPointToPoint", "depth", "PathfindingHelper", "Object3D", "super", "_playerMarker", "Mesh", "SphereGeometry", "MeshBasicMaterial", "color", "_targetMarker", "BoxGeometry", "_nodeMarker", "_stepMarker", "_pathMarker", "_pathLineMaterial", "LineBasicMaterial", "linewidth", "_pathPointMaterial", "_pathPointGeometry", "_markers", "marker", "visible", "setPath", "children", "concat", "setXYZ", "Line", "setPlayerPosition", "setTargetPosition", "setNodePosition", "setStepPosition", "reset"]
}
